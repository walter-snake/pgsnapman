#!/bin/bash

# pgsnap_dump: starts postgres dumps
#                     must run on a backup node, with passwordless (.pgpass does the job) to all databases
#                     should be backed up
#
# $1 pgsql instance snapshot id <pginstanceid_pgdns_pgport>, resolves to snapshot/pgsqlinstance directory (must contain the job list)
# $2 dump job id
# $3 verbosity [VERBOSE|empty]
# $4 startup type [CRON|SINGLE]
#      CRON will use the cached jobs in <snapshots>/<serverinstance>/dumpjobs.list
#      SINGLE uses the jobs listed in <temp>/$5.singledumpjobs.list
# $5 single run process id
#
# Actions taken:
#   1 reads configuration from locally cached data, so it isn't depending on the availability of the central database
#   2 starts pg_dump and/or pg_dumpall
# 
# Actual backups are usually started by cron on this machine, but you may invoke it with a backup id at any time.

# ======================================
# Initialization
# ======================================
VERBOSITY=$3
STARTTYPE=$4
SINGLERUNPID=$5

# Get the script directory (must do this first)
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
SCRIPTPATH="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

# Check cmd args
if [ "${STARTTYPE}" == "" ]; then
  echo "ERROR pgsnap_dump no startup type provided"
  exit 1
fi
if [ "${STARTTYPE}" == "SINGLE" ] && [ "${SINGLERUNPID}" == "" ]; then
  echo "ERROR pgsnap_dump needs a process id in SINGLE mode"
  exit 1
fi
# Set a fake PID when running in CRON mode, so we always have a complete set of cmd args when starting other tools
#if [ "${STARTTYPE}" == "CRON" ]; then
#  SINGLERUNPID=0
#fi

# Catalog database needed?
PGSCDB_REQUIRED=NO

# Load functions, will also perform initialization operations
. ${SCRIPTPATH}/pgsnap_lib

# ============================
# Functions
# ============================

# Prepare for starting a custom script
# Writes out all current variables to a temp file
function preparescriptrun {
  echo "JOBID=${jobid}" > ${TEMPDIR}/$$.scriptinit.temp
  echo "INITIMESTAMP=${INITIMESTAMP}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "VERBOSITY=${VERBOSITY}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "STARTTYPE=${STARTTYPE}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "SINGLERUNPID=${SINGLERUNPID}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "JOBDIR=${jobdir}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "BUNAME=${buname}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "PGSQLHOST=\"${pgsqlhost}\"" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "PGSQLPORT=${pgsqlport}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "PGSQLSUPERUSER=${pgsqlsuperuser}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "PGSQLDBNAME=${dbname}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "SCHEMA=${schema}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "ROOTDIR=${ROOTDIR}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "LOGDIR=${LOGDIR}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "TEMPDIR=${TEMPDIR}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "UPLOADDIR=${UPLOADDIR}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "PGBIN=${pgbin}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "PGSNAPMANLOG=${PGSNAPMANLOG}" >> ${TEMPDIR}/$$.scriptinit.temp
  echo "TOOL_LOG=${TOOL_LOG}" >> ${TEMPDIR}/$$.scriptinit.temp
  mkdir ${jobdir}/${buname}
}

# Get the global ACL's from the database
# $1 database name
# $2 store in file (full path)
function dumpglobalacls {
  # Check name
  if [ "${1}" == *";"* ]; then
    return
  fi
  
  # The nice way, using a function (but that's not present in every database)
  # local sql="select * from get_globalacl('${1}') as (datname name, acl_role text, acl_rights text);"
  # Ugly but acceptable: we checked for ; in the name, but probably nothing will work with a weird database name (you'll have to connect in the first place)
  local sql="with acls as (select datname, split_part(acl, '=', 1) as acl_role \
  , (regexp_split_to_array(acl, '[=/]'))[2] as acl_rights \
from (select datname, unnest(datacl)::text as acl \
  from pg_database) a \
) \
select datname,acl_role,acl_rights from acls \
where datname = '${1}'"
  local acls=`${pgbin}/psql ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --dbname="${1}" -F '|' -A -t -c "${sql}"`
  if [ "acls" != "" ]; then
    echo "REVOKE ALL ON DATABASE ${1} FROM public;" > ${2}
  fi
  for line in $acls; do
    local acl="$(getfieldvalue ${line} 3)"
    local role="$(getfieldvalue ${line} 2)"
    if [ "${role}" == "" ]; then
      role="public"
    fi
    echo "REVOKE ALL ON DATABASE ${1} FROM ${role};" >> ${2}
    if [[ "${acl}" =~ "C" ]]; then
      echo "GRANT CREATE ON DATABASE ${1} TO ${role};" >> ${2}
    fi
    if [[ "${acl}" =~ "T" ]]; then
      echo "GRANT TEMP ON DATABASE ${1} TO ${role};" >> ${2}
    fi
    if [[ "${acl}" =~ "c" ]]; then
      echo "GRANT CONNECT ON DATABASE ${1} TO ${role};" >> ${2}
    fi
  done
}

# Start a specific dump job 
# $1 path to postgres instance snapshot root directory
# $2 id of job to start
function startpgsnapjob {
  if [ "${STARTTYPE}" == "CRON" ]; then
    local dumpjobs=${DUMPSNAP}/${1}/dumpjobs.list
  else
    local dumpjobs=${TEMPDIR}/${SINGLERUNPID}.singledumpjobs.list
  fi
  snaplog "INFO" "configuration - reading job info from ${dumpjobs} [$2]"
  row="$(findrow ${dumpjobs} ${2})"
  if [ "${row}" == "" ]; then
    RETVAL="JOB_NOT_FOUND"
    return
  fi
  jobid=$(getfieldvalue "${row}" 1)
  pgsqlid=$(getfieldvalue "${row}" 3)
  pgsqlhost=$(getfieldvalue "${row}" 16)
  pgsqlport=$(getfieldvalue "${row}" 17)
  pgsqlsuperuser=$(getfieldvalue "${row}" 18)
  dbname=$(getfieldvalue "${row}" 4)
  butype=$(getfieldvalue "${row}" 5)
  schema=$(getfieldvalue "${row}" 6)
  cron=$(getfieldvalue "${row}" 7)
  jobstatus=$(getfieldvalue "${row}" 13)
  jobtype=$(getfieldvalue "${row}" 14)
  restorejobid=$(getfieldvalue "${row}" 19)
  dumpoptions=$(getfieldvalue "${row}" 20)
  # Set schema_part for the dump name, NOTE special exception:
  # when butype is set to SCRIPT, we want to ignore the schema field.
  if [ "${schema}" == "*" ] || [ "${butype}" == "SCRIPT" ]; then
    schema_part=""
  else
    dumpoptions="--schema=\"${schema}\" ${dumpoptions}"
    schema_part=".${schema}"
  fi

  # Resolve host
  pgsqlhost=$(resolvepghost ${pgsqlhost})

  # Display a lot of data in verbose mode
  if  [ "$VERBOSITY" == "VERBOSE" ]; then
    echo "PgSnapDump job data configuration"
    echo "jobid:          ${jobid}"
    echo "pg id:          ${pgsqlid}"
    echo "pg host:        ${pgsqlhost}"
    echo "pg port:        ${pgsqlport}"
    echo "pg superuser:   ${pgsqlsuperuser}"
    echo "dbname:         ${dbname}"
    echo "butype:         ${butype}"
    echo "schema:         ${schema}"
    echo "cron:           ${cron}"
    echo "job status:     ${jobstatus}"
    echo "job type:       ${jobtype}"
    echo "dump options:   ${dumpoptions}"
    echo "restore job id: ${restorejobid}"
    echo ""
  fi

  # Determine job type, as naming schema's differ 
  if [ "${butype}" == "CLUSTER_SCHEMA" ]; then
    jobdir=${DUMPSNAP}/${1}/${jobid}_cluster.schema
  else
    jobdir=${DUMPSNAP}/${1}/${jobid}_${dbname}${schema_part}
  fi
  mkdir -p ${jobdir}

  # Set logfile
  TOOL_LOG=${jobdir}.log

  # Get timestamp, backup name, postgres version
  buname=${jobid}_${dbname}${schema_part}_${butype}_${INITIMESTAMP}
  log "INFO" "job id ${jobid} - ${jobtype} backup ${buname}"
  # Check postgres server version and binary availability 
  pgversion=$(getpgversion "${pgsqlhost}" "${pgsqlport}" "${pgsqlsuperuser}" "${dbname}")
  if [ "${pgversion}" == "" ]; then
    log "ERROR" "job id ${jobid} - could not connect to postgres instance: ${pgsqlsuperuser}@${pgsqlhost}:${pgsqlport}/${dbname}"
    ERRORS=1
  else
    eval pgbinvar=PGBIN${pgversion}
    pgbin=${!pgbinvar}
  fi
  # check if pg dump exists
  if [ ! -e ${pgbin}/pg_dump ]; then
    log "ERROR" "job id ${jobid} - job can not run - pg_dump not found, check PGBINxx paths in config file ${CONFIGFILE}"
    ERRORS=1
  else
    STARTTIME=`date '+%s'`
    log "INFO" "job id ${jobid} - ${butype} dump started with options ${dumpoptions}"
    if [ "${butype}" == "CLUSTER_SCHEMA" ]; then
      ext=".sql"
      snaplog "INFO" "dumping - ${pgbin}/pg_dumpall ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} -l ${dbname} -s -o -f ${jobdir}/${buname}${ext} -v"
      ${pgbin}/pg_dumpall ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} -l ${dbname} -s -o -f ${jobdir}/${buname}${ext} -v 2>> ${jobdir}/${buname}.log
      if [ "$?" == "0" ]; then
        gzip ${jobdir}/${buname}${ext}
        if [ "$?" == "0" ]; then
          ext=".sql.gz"
        else
          log "ERROR" "job id ${jobid} - errors occured during gzip for ${jobdir}/${buname}${ext}"
          ERRORS=1
        fi
      else
        log "ERROR" "job id ${jobid} - errors occured during pg_dumpall (cluster schema) for ${buname}${ext}"
        ERRORS=1
      fi
    elif  [ "${butype}" == "SCRIPT" ]; then
      local scriptname=`echo "${dumpoptions}" | cut -d ' ' -f 1`
      if [ ! -e "${SCRIPTDIR}/${scriptname}" ]; then
        snaplog "ERROR" "script not found: ${SCRIPTDIR}/${scriptname}"
        exit 1
      else
        preparescriptrun
        snaplog "INFO" "script started: ${SCRIPTDIR}/${dumpoptions}"
        # Separate script name from its own options
        local scriptoptions=`echo "${dumpoptions}" | awk '{ print substr($0, length($1)+1) }'`
        ${SCRIPTDIR}/${scriptname} ${TEMPDIR}/$$.scriptinit.temp >> ${jobdir}/${buname}.log
        local ec=$?
        if [ "$ec" != "0" ]; then
          log "ERROR" "job id ${jobid} - script exited with code ${ec} for ${jobdir}/${buname}"
          ERRORS=1
        fi
      fi
    else 
      # globals (tablespaces, users)
      ${pgbin}/pg_dumpall ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} -l ${dbname} -g -o -f ${jobdir}/${buname}.cluster_globals.sql -v 2>> ${jobdir}/${buname}.log
      if [ "$?" != "0" ]; then
        log "ERROR" "job id ${jobid} - errors occured during pg_dumpall (globals): ${buname}"
        ERRORS=1
      fi
      # globals (connect rights)
      dumpglobalacls "${dbname}" ${jobdir}/${buname}.database_globals.sql
      # db dump (possibly schema-only)
      snaplog "INFO" "dumping - ${pgbin}/pg_dump ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} ${dumpoptions} -b -o -Fd -f ${jobdir}/${buname} -v ${dbname}"
      ${pgbin}/pg_dump ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} ${dumpoptions} -b -o -Fd -f ${jobdir}/${buname} -v ${dbname} 2>>  ${jobdir}/${buname}.log
      if [ "$?" != "0" ]; then
        log "ERROR" "job id ${jobid} - errors occured during pg_dump: ${buname}"
        ERRORS=1
      fi
      # extract schema sql, testing dump
      #${pgbin}/pg_restore ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --schema-only -f ${jobdir}/${buname}.schema -v ${jobdir}/${buname} 2>>  ${jobdir}/${buname}.log
      ${pgbin}/pg_restore ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --schema-only -f /dev/null -v ${jobdir}/${buname} 2>>  ${jobdir}/${buname}.log
      if [ "$?" != "0" ]; then
        log "ERROR" "job id ${jobid} - errors occured during schema creation from dump: ${buname}"
        ERRORS=1
      fi
    fi
    # Size on disk
    SIZEONDISK=`du -k ${jobdir}/${buname}${ext} | awk '{print $1 * 1024}'`
    # Db Size
    DBSIZE=$(getdbsize "${pgsqlhost}" ${pgsqlport} "${pgsqlsuperuser}" "${dbname}" "${schema}")
    if [ "${SIZEONDISK}" == "0" ]; then
      ERRORS=1
    fi
    ENDTIME=`date '+%s'`
    let "ELAPSEDTIME = $ENDTIME - $STARTTIME"
    log "INFO" "job id ${jobid} - dump ended - elapsed time ${ELAPSEDTIME}[s]"
 fi # if pg_dump exists
}

# ================================================================================
# MAIN
# ===============================================================================

# Start message
snaplog "INFO" "init - pgsql_instance.job: [`basename ${1}`].[${2}]"

# Get pgsql instance status (the instance that contains the db to be backed up)
INSTANCESTATUS=$(getinstancestatus ${1})

# Display information
if [ "$VERBOSITY" == "VERBOSE" ]; then
  echo ""
  echo "+--------------------+"
  echo "| pgsnap_dump        |"
  echo "+--------------------+"
  echo ""
  echo "Config file:           ${CONFIGFILE}"
  echo ""
  echo "PgSnapman worker fqdn: ${FQDN}"
  echo "PgSnapman worker id:   ${BUWORKERID}"
  echo "PgSnapman log:         ${PGSNAPMANLOG}"
  echo ""
  echo "Global pgsnapman catalog db"
  echo "  db:   ${PGSCDB}"
  echo "  host: ${PGSCHOST}"
  echo "  port: ${PGSCPORT}"
  echo "  user: ${PGSCUSER}"
  echo ""
  echo "Pgsql instance status: ${INSTANCESTATUS}"
  echo ""
fi

if [ "${INSTANCESTATUS}" == "HALTED" ] && [ "${STARTTYPE}" == "CRON" ]; then
  snaplog "WARNING" "abandon job - pgsql_instance halted [`basename ${1}`]"
  exit 0
fi

# Start the dumpjob
startpgsnapjob $1 $2

# Check results, log status etc.
if [ "${RETVAL}" == "JOB_NOT_FOUND" ]; then
  snaplog "ERROR" "configuration - pgsql_instance.job [`basename ${1}`].[${2}] not found in ${STARTTYPE} job list"
  exit 1
fi

if [ "$VERBOSITY" == "VERBOSE" ]; then
  echo "Dump location:   ${jobdir}"
  echo "Dump name:       ${buname}${ext}"
  echo "General job log: ${TOOL_LOG}"
  echo "pg_dump log:     ${jobdir}/${buname}.log"
  echo ""
fi

# File format for database import (using COPY FROM STDIN)
# columns: pgsnap_job_id starttime endtime status bu_name bu_location dbsize dumpsize

# Write status info for log and catalog
if [ "${ERRORS}" == "1" ]; then
  snaplog "ERROR" "finished - pgsql_instance.job [`basename ${1}`].[${2}] with errors, check: ${TOOL_LOG}"
  jobresult="FAILED"
  DBSIZE=-1
  SIZEONDISK=-1
else
  snaplog "INFO" "finished - pgsql_instance.job [`basename ${1}`].[${2}]"
  jobresult="SUCCESS"
fi

# Write catalog data file for upload, symlink in central upload dir
copylog=${jobdir}/${buname}.catalog.dat
preparecatalogdata "${2}\t${INITIMESTAMP}\t`date +'%Y%m%dT%H%M%S'`\t${jobresult}\t${buname}${ext}\t${jobdir}\t${DBSIZE}\t${SIZEONDISK}" "${copylog}" "NEW" "UPLOAD"

# Next procedures, set exit code
if [ "${jobresult}" == "SUCCESS" ]; then
  if [ "${butype}" == "FULL" ]; then
    ${SCRIPTPATH}/pgsnap_dedup ${jobdir}/${buname} SILENT ${jobid}
  fi
  if [ "${restorejobid}" != "-1" ]; then
    ${SCRIPTPATH}/pgsnap_restore ${restorejobid} ${jobdir}/${buname} TRIGGER
  fi
  exit 0
else
  exit 1
fi

# EOF
