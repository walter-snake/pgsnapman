#!/bin/bash

# pgsnapman shell script tools common initialization, and function library

# Config file location (if not found, script directory will be searched)
CONFIGFILE=/etc/pgsnapman/pgsnapman.config

# Run/lock management
# ------------------------------------------------

# Write lock file
# $1 job id
# $2 commandline or other useful info (optional)
function lock {
  echo -n "${2}" > "${TEMPDIR}/$$.$1.${TOOLNAME}.lock"
}

# Exit, remove our own temp files
# $1 error code
function cleanupexit {
  # Remove temp files, including lock
  rm -f ${TEMPDIR}/$$.*.${TOOLNAME}*
  exit $1
}

# Checks lock files for running job
# $1 job id
function isjobrunning {
  local ec=0
  local findresult=`find ${TEMPDIR} -name "*.$1.${TOOLNAME}.lock"`
  if [ "${findresult}" != "" ]; then
    for fr in ${findresult}; do
      local chkpid=`echo "${findresult}" | cut -d '.' -f1`
      chkpid=`basename ${chkpid}`
      ps -p $chkpid &> /dev/null
      if [ "$?" == "1" ]; then
        rm -f ${findresult}
      else
        local MSG="exit: job id ${1}.${TOOLNAME} appears to be running - pid ${chkpid}" 
        snaplog "WARNING" "${MSG}"
        ec=1
      fi
    done
  fi
  echo ${ec}
}

# Function set platform
function setplatform {
  if [[ "$OSTYPE" == "linux-gnu" ]]; then
    PLATFORM="GNU"
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    PLATFORM="BSD"
  elif [[ "$OSTYPE" == "freebsd"* ]]; then
    PLATFORM="BSD"
  elif [[ "$OSTYPE" == "cygwin" ]]; then
    PLATFORM="${OSTYPE}"
  else
    # Unknown, assume linux-gnu
    PLATFORM="GNU"
fi
}

# Grep version (BSD/GNU need different flags)
function setgrep {
  if [ "$(grep -V | grep BSD)" == "" ]; then
    # assume GNU
    GRPFLG="-P"
  else
    GRPFLG="-E"
  fi
}

# Messages
# ------------------------------------------------------------------

# Echo, depending on verbosity
# $1 the message
function talk {
  if [ "${VERBOSITY}" == "VERBOSE" ]; then
    echo "$1"
  fi
}

# Write a log entry to the main snapman log
# $1: log level
# $2: log message
function snaplog {
  if [ -d "${LOGDIR}" ]; then
    echo "`date '+%Y%m%dT%H%M%S%z'` $1 ${TOOLNAME} ${2}" >> ${PGSNAPMANLOG}
  fi
}

# Write a log entry to the tool log
# $1: log level
# $2: log message
# $3: NEW: start new log
function log {
  if [ "${3}" == "NEW" ]; then
    echo "`date '+%Y%m%dT%H%M%S%z'` $1 ${TOOLNAME} ${2}" > ${TOOL_LOG}
  else
    echo "`date '+%Y%m%dT%H%M%S%z'` $1 ${TOOLNAME} ${2}" >> ${TOOL_LOG}
  fi
}

# Status info
# -------------------------------------------------------------------

# Sets the pgsnap_worker id (quit on error if requested)
# Requires PGSCDB_REQUIRED to be set (before sourcing this library)
# When db not required, we obtain the value from the cached data
function setworkerid {
  BUWORKERID=`${PGSCBIN}/psql ${PGSCHOST} -p ${PGSCPORT} -U ${PGSCUSER} --dbname=${PGSCDB} -F '|' -A -t -c "SELECT get_pgsnap_worker_id('${FQDN}');" 2> /dev/null`
  if [ "$?" != "0" ] || [ "${BUWORKERID}" == "" ]; then
    if [ "${PGSCDB_REQUIRED}" == "NO" ]; then
      ERRCODE=0
      snaplog "WARNING" "init - could not connect to catalog database (ignored)"
      BUWORKERID=`cat ${ROOTDIR}/workerid`
    else
      ERRCODE=1
      snaplog "ERROR" "init - could not connect to catalog database (fatal)"
    fi
  fi
}

# Get the hostname, resolve 'local' connections
# $1 FQDN psotgres host
function resolvepghost {
  if [ "${1}" == "local" ]; then
    local pgh=""
  else
    local pgh="-h${1}"
  fi
  echo "${pgh}"
}

# Get (catalog) status of the postgres instance
# Check with catalog database (you can turn of dumps immediately), if not available, use cached info
# Active wins, it will try to do something unless explicitly halted (if both active and halted files are present, active wins).
# $1 instance name as formatted in directory <id>_<fqdn>_<port>
function getinstancestatus {
  # Init/activate by default
  if [ ! -e ${DUMPSNAP}/${1}/status ]; then
    echo "ACTIVE" > "${DUMPSNAP}/${1}/status" 
  fi
  # Get data from server
  local instancestatus="UNKNOWN"
  local instanceid=$(echo `basename "$1"` | cut -d '_' -f 1)
  instancestatus=`${PGSCBIN}/psql ${PGSCHOST} -p ${PGSCPORT} -U ${PGSCUSER} --dbname=${PGSCDB} -A -t -c "SELECT status FROM pgsql_instance WHERE id = ${instanceid}"`
  if [ "$?" != "0" ]; then
      instancestatus=`cat ${DUMPSNAP}/${1}/status`
  else
    # compare with cached version, if different: store the current value
    if [ "${instancestatus}" != "`cat ${DUMPSNAP}/${1}/status`" ]; then
      echo "${instancestatus}" > "${DUMPSNAP}/${1}/status"
      snaplog "INFO" "instance status changed to: ${instancestatus}"
    fi
  fi

  echo "${instancestatus}"
}

# Get (catalog) status of the worker instance
# Check with catalog database (you can turn of workers immediately), if not available, use cached info
function getworkerstatus {
  # Init/activate by default
  if [ ! -e ${ROOTDIR}/status ]; then
    echo "ACTIVE" > ${ROOTDIR}/status 
  fi
  # Get data from server
  local workerstatus="UNKNOWN"
  workerstatus=`${PGSCBIN}/psql ${PGSCHOST} -p ${PGSCPORT} -U ${PGSCUSER} --dbname=${PGSCDB} -A -t -c "SELECT status FROM pgsnap_worker WHERE id = ${BUWORKERID}"`
  if [ "$?" != "0" ]; then
      workerstatus=`cat ${ROOTDIR}/status`
  else
    # compare with cached version, if different: store the current value
    if [ "${workerstatus}" != "`cat ${ROOTDIR}/status`" ]; then
      echo "${workerstatus}" > ${ROOTDIR}/status
      snaplog "INFO" "worker status changed to: ${workerstatus}"
    fi
  fi
  echo "${workerstatus}"
}

# Retrieve the bin location for a specific postgres version
# $1 version
function getpgbinlocation {
  eval pgbinvar=PGBIN${1}
  local pgbin=${!pgbinvar}
  # check if pg dump exists
  if [ ! -e ${pgbin}/psql ]; then
    snaplog "ERROR" "postgres tools not found, check PGBINxx paths in config file ${CONFIGFILE}"
    ERRORS=1
  else
    echo ${pgbin}
  fi
}

# Catalog database
# -----------------------------------------

# Gets the postgres server version
# $1 hostname (use local for local pipe connections)
# $2 port
# $3 user
# $4 db name
function getpgversion {
  ${PGSCBIN}/psql ${1} -p ${2} -U ${3} --dbname=${4} -c "SELECT 1" &> /dev/null
  if [ "$?" == "0" ]; then
    local result=`${PGSCBIN}/psql ${1} -p ${2} -U ${3} --dbname=${4} -A -t -c "show server_version;"`
    local pgv=$(echo "${result}" | cut -d '.' -f 1)$(echo "${result}" | cut -d '.' -f 2)
  else
    pgv=""
  fi
  echo "${pgv}"
}

# Checks if a database exists
# $1 hostname (use local for local pipe connections)
# $2 port
# $3 user
# $4 connect to database
# $5 check database name
# returns 0 (not exists) or 1 (exists) 
function dbexists {
  local c=`${PGSCBIN}/psql ${1} -p ${2} -U ${3} --dbname=${4} -A -t -c "select count(*) from pg_database where datname = trim(both '\"' from '$5');"`
  echo ${c}
}

# Check if schema exists
# $1 hostname (use local for local pipe connections)
# $2 port
# $3 user
# $4 db name
# $5 schema name
# returns 0 (not exists) or 1 (exists) 
function schemaexists {
  local c=`${PGSCBIN}/psql ${1} -p ${2} -U ${3} --dbname=${4} -A -t -c "select count(*) from pg_namespace where nspname = trim(both '\"' from '$5');"`
  echo ${c}
}

# Get the actual size of the database, or a specific schema
# $1 hostname (use local for local pipe connections)
# $2 port
# $3 user
# $4 db name
# $5 schema name ('*' represents entire database)
function getdbsize {
  if [ "$5" == "*" ]; then
    local sql="SELECT COALESCE(sum(total_bytes), -1) AS total_bytes FROM ( SELECT *, total_bytes-index_bytes-COALESCE(toast_bytes,0) AS table_bytes \
    FROM ( SELECT c.oid,nspname AS table_schema, relname AS TABLE_NAME , c.reltuples AS row_estimate , pg_total_relation_size(c.oid) AS total_bytes , \
    pg_indexes_size(c.oid) AS index_bytes , pg_total_relation_size(reltoastrelid) AS toast_bytes \
    FROM pg_class c \
    LEFT JOIN pg_namespace n ON n.oid = c.relnamespace \
    WHERE relkind = 'r' ) a ) a;"
  else
    local sql="SELECT COALESCE(sum(total_bytes),-1) AS total_bytes FROM ( SELECT *, total_bytes-index_bytes-COALESCE(toast_bytes,0) AS table_bytes \
    FROM ( SELECT c.oid,nspname AS table_schema, relname AS TABLE_NAME , c.reltuples AS row_estimate , pg_total_relation_size(c.oid) AS total_bytes , \
    pg_indexes_size(c.oid) AS index_bytes , pg_total_relation_size(reltoastrelid) AS toast_bytes \
    FROM pg_class c \
    LEFT JOIN pg_namespace n ON n.oid = c.relnamespace \
    WHERE relkind = 'r' ) a ) a \
    WHERE table_schema = trim(both '\"' from '$5') \
    GROUP BY table_schema;"
  fi
  local dbsize=`${pgbin}/psql ${1} -p ${2} -U ${3} --dbname=${4} -A -t -c "${sql}"`
  if [ "${dbsize}" == "" ]; then
    dbsize=-1
  fi
  echo "${dbsize}"
}

# Mark a single run job as halted in the database
# $1 job class/type [DUMP|RESTORE]
# $2 job id
# $3 job status [HALTED|ACTIVE]
function setjobstatus {
  local sql
  if [ "${1}" == "DUMP" ]; then
    sql="SELECT set_dumpjobstatus($2, '$3');"
  else
    sql="SELECT set_restorejobstatus($2, '$3');"
  fi
  ${PGSCBIN}/psql ${PGSCHOST} -p ${PGSCPORT} -U ${PGSCUSER} --dbname=${PGSCDB} -c "$sql" > /dev/null
  ERRCODE=$?
}

# Get the job status from the server, latest state
# $1 job class/type [DUMP|RESTORE]
# $2 job id
# Returns jobstatus (text)
function getjobstatus {
  local sql
  if [ "${1}" == "DUMP" ]; then
    sql="SELECT get_dumpjobstatus($2);"
  else
    sql="SELECT get_restorejobstatus($2);"
  fi
  local js
  js=`${PGSCBIN}/psql ${PGSCHOST} -p ${PGSCPORT} -U ${PGSCUSER} --dbname=${PGSCDB} -A -t -c "$sql" 2> /dev/null`
  ERRCODE=$?
  RETVAL="${js}"
}

# Verify and write upload data for the catalog database
# Checks format based on file name pattern (destination table) and regular expression
# $1 datarow (pgsql copy format)
# $2 destination file
# $3 file: [ADD|NEW]
# $4 optional: UPLOAD (creates link in upload dir)
function preparecatalogdata {
  if [ "$1" == "" ]; then
    return
  fi

  local format=`echo "${2}" | awk -F '.' '{print $(NF-1)}'`
  # Verify the upload format using regular expression
  if [ "${format}" == "catalog" ]; then
    if [ "`echo -e "${1}" | grep ${GRPFLG} '^\d+\t\d{8}T\d{6}[+-]\d+\t\d{8}T\d{6}[+-]\d+\t[A-Z]+\t[a-zA-Z0-9_\.\/]+\t[a-zA-Z0-9_\.\/]+\t-?\d+\t-?\d+\t.*\t.*\t.*\t.*\t.*\t\d+\t.*\t.*\t\d+$'`" == "" ]; then
      snaplog "ERROR" "catalog upload wrong format: $1"
      return
    fi
  elif [ "${format}" == "message" ]; then
    if [ "`echo -e "${1}" | grep ${GRPFLG} '^\d{8}T\d{6}[+-]\d+\t((INFO|WARNING|ERROR|CRITICAL|DEBUG))\t.+\t.*\t((CACHE_CONFIG|DUMP|RESTORE|VERIFY|DEDUP))\t-?\d+\t\d+$'`" == "" ]; then
      snaplog "ERROR" "message upload wrong format: $1"
      return
    fi
  else
      snaplog "ERROR" "catalog upload format unknown: $2"
      return
  fi
  
  # Add to existing file, or overwrite
  if [ "${3}" == "ADD" ]; then
    echo -e "${1}" >> ${2}
  else
    echo -e "${1}" > ${2}
  fi
  # Create link in upload dir
  if [ "${4}" == "UPLOAD" ]; then
    ln -s ${2} ${UPLOADDIR}/
  fi
}

# Table functions
# -----------------------------------------------------

# Extract a row from a 'table' by first column
# $1 file with data rows, | separated fields
# $2 search value (first field)
function findrow {
  local row=`grep ${GRPFLG} "^${2}\|" "${1}"`
  echo "${row}"
}

# Get field value from a row
# $1 row with | separated fields
# $2 field index to get the value from
# $3 other field separator (optional)
function getfieldvalue {
  local fs
  if [ "${3}" != "" ]; then fs=${3}; else fs="|"; fi
  local val=$(echo "${1}" | cut -d "${fs}" -f ${2})
  echo "${val}"
}

# Scripts/files
# ------------------------------------------------------
# Downloads a script, writes it to the script directory
# $1 script name
function getscript {
  local sql="SELECT get_scriptcode('$1')"
  ${PGSCBIN}/psql ${PGSCHOST} -p ${PGSCPORT} -U ${PGSCUSER} --dbname=${PGSCDB} -A -t -c "${sql}" > ${SCRIPTDIR}/$1
}

# Reset all global error codes and messages
function reseterrors {
  ERROR=""
  MSG=""
  ERRCODE=0
}

# =====================================
# Init actions
# =====================================

# Global super variables for messaging when using functions
RETVAL=""
ERROR=""
MSG=""
ERRCODE=0

# Try to find the config file, check and read
if [ ! -e ${CONFIGFILE} ]; then
  CONFIGFILE=${SCRIPTPATH}/pgsnapman.config
fi
if [ -e ${CONFIGFILE} ]; then
  . ${CONFIGFILE}
else
  echo "pgsnapman config file not found: "${CONFIGFILE}
  cleanupexit 1
fi

# Determine and set platform
setplatform

# Set grep version
setgrep

# Set hostname
if [ "${WORKER_DNS_NAME}" != "" ]; then
  FQDN="${WORKER_DNS_NAME}"
else 
  FQDN=`hostname -f`
fi

# Test existing root dir
if [ "`echo "${ROOTDIR}" | grep ' '`" != "" ]; then
  echo "ERROR PgSnapMan root name contains spaces [${ROOTDIR}]"
  cleanupexit 1
fi
if [ ! -d "${ROOTDIR}" ]; then
  echo "ERROR PgSnapMan root directory does not exist [${ROOTDIR}]"
  cleanupexit 1
fi

# Verify user
if [ "`whoami`" != "${PGSNAPMANUSER}" ]; then
  echo "ERROR pgsnapman must run as user: ${PGSNAPMANUSER}"
  cleanupexit 4
fi

# Set toolname
TOOLNAME=`basename $0`

# Set tool log (you may overwrite this, of course)
TOOL_LOG=${LOGDIR}/${TOOLNAME}.log

# Set script dir
SCRIPTDIR=${ROOTDIR}/script

# Set upload dir
UPLOADDIR=${ROOTDIR}/upload

# Get a timestamp
INITIMESTAMP=`date '+%Y%m%dT%H%M%S%z'`

# Set the hostname for the pgsnapman database (put '-h ' in front of it for non local connections)
PGSCHOST=$(resolvepghost ${PGSCHOST})

# Sets the worker id for this worker instance (either from database or from file cache)
setworkerid
if [ ${ERRCODE} -gt 0 ]; then
  echo "INIT: WORKER ID could not be set, is the database configured and this worker registered?"
  cleanupexit ${ERRCODE}
fi

# Get worker status, quit if HALTED (any tool will quit when the worker is halted)
if [ "$(getworkerstatus)" == "HALTED" ]; then cleanupexit 0; fi

# Write tool init log entry
if [ "${LOGINIT}" != "NO" ]; then snaplog "INFO" "init - using config: ${CONFIGFILE} - platform mode: ${PLATFORM} - grep flags: ${GRPFLG}"; fi

