#!/bin/bash

# pgsnapman shell script tools common initialization, and function library

# Config file location (if not found, script directory will be searched)
CONFIGFILE=/etc/pgsnapman/pgsnapman.config

# Write a log entry to the main snapman log
# $1: log level
# $2: log message
function snaplog {
  echo "`date '+%Y%m%dT%H%M%S'` $1 ${TOOLNAME} ${2}" >> ${PGSNAPMANLOG}
}

# Write a log entry to the tool log
# $1: log level
# $2: log message
# $3: NEW: start new log
function log {
  if [ "${3}" == "NEW" ]; then
    echo "`date '+%Y%m%dT%H%M%S'` $1 ${TOOLNAME} ${2}" > ${TOOL_LOG}
  else
    echo "`date '+%Y%m%dT%H%M%S'` $1 ${TOOLNAME} ${2}" >> ${TOOL_LOG}
  fi
}

# Gets pgsnap_worker id (quit on error if requested)
# Requires PGSCDB_REQUIRED to be set (before sourcing this library)
function getworkerid {
  local bwid=`${PGSCBIN}/psql ${PGSCHOST} -p ${PGSCPORT} -U ${PGSCUSER} --dbname=${PGSCDB} -F '|' -A -t -c "SELECT get_pgsnap_worker_id('${FQDN}');"`
  if [ "$?" != "0" ] || [ "${bwid}" == "" ]; then
    if [ "${PGSCDB_REQUIRED}" == "NO" ]; then
      snaplog "WARNING" "init - could not connect to catalog database (ignored)"
    else
      snaplog "ERROR" "init - could not connect to catalog database (fatal)"
      exit 2
    fi
  fi
  echo "${bwid}"
}

# Get the hostname, resolve 'local' connections
# $1 FQDN psotgres host
function resolvepghost {
  if [ "${1}" == "local" ]; then
    local pgh=""
  else
    local pgh="-h ${1}"
  fi
  echo "${pgh}"
}

# Get (catalog) status of the postgres instance
# Check with catalog database (you can turn of dumps immediately), if not available, use cached info
# Active wins, it will try to do something unless explicitly halted (if both active and halted files are present, active wins).
# $1 instance name as formatted in directory <id>_<fqdn>_<port>
function getinstancestatus {
  # Init/activate by default
  if [ ! -e ${DUMPSNAP}/${1}/status ]; then
    echo "ACTIVE" > "${DUMPSNAP}/${1}/status" 
  fi
  # Get data from server
  local instancestatus="UNKNOWN"
  local instanceid=$(echo `basename "$1"` | cut -d '_' -f 1)
  instancestatus=`${PGSCBIN}/psql ${PGSCHOST} -p ${PGSCPORT} -U ${PGSCUSER} --dbname=${PGSCDB} -A -t -c "SELECT status FROM pgsql_instance WHERE id = ${instanceid}"`
  if [ "$?" != "0" ]; then
      instancestatus=`cat ${DUMPSNAP}/${1}/status`
  else
    # compare with cached version, if different: store the current value
    if [ "${instancestatus}" != "`cat ${DUMPSNAP}/${1}/status`" ]; then
      echo "${instancestatus}" > "${DUMPSNAP}/${1}/status"
      snaplog "INFO" "instance status changed to: ${instancestatus}"
    fi
  fi

  echo "${instancestatus}"
}

# Get (catalog) status of the worker instance
# Check with catalog database (you can turn of workers immediately), if not available, use cached info
function getworkerstatus {
  # Init/activate by default
  if [ ! -e ${ROOTDIR}/status ]; then
    echo "ACTIVE" > ${ROOTDIR}/status 
  fi
  # Get data from server
  local workerstatus="UNKNOWN"
  workerstatus=`${PGSCBIN}/psql ${PGSCHOST} -p ${PGSCPORT} -U ${PGSCUSER} --dbname=${PGSCDB} -A -t -c "SELECT status FROM pgsnap_worker WHERE id = ${BUWORKERID}"`
  if [ "$?" != "0" ]; then
      workerstatus=`cat ${ROOTDIR}/status`
  else
    # compare with cached version, if different: store the current value
    if [ "${workerstatus}" != "`cat ${ROOTDIR}/status`" ]; then
      echo "${workerstatus}" > ${ROOTDIR}/status
      snaplog "INFO" "worker status changed to: ${workerstatus}"
    fi
  fi
  echo "${workerstatus}"
}

# Gets the postgres server version
# $1 hostname (use local for local pipe connections)
# $2 port
# $3 user
# $4 db name
function getpgversion {
  ${PGSCBIN}/psql ${1} -p ${2} -U ${3} --dbname=${4} -c "SELECT 1" &> /dev/null
  if [ "$?" == "0" ]; then
    local result=`${PGSCBIN}/psql ${1} -p ${2} -U ${3} --dbname=${4} -A -t -c "show server_version;"`
    local pgv=$(echo "${result}" | cut -d '.' -f 1)$(echo "${result}" | cut -d '.' -f 2)
  else
    pgv=""
  fi
  echo "${pgv}"
}


# Get the actual size of the database, or a specific schema
# $1 hostname (use local for local pipe connections)
# $2 port
# $3 user
# $4 db name
# $5 schema name ('*' represents entire database)
function getdbsize {
  if [ "$5" == "*" ]; then
    local sql="SELECT COALESCE(sum(total_bytes), -1) AS total_bytes FROM ( SELECT *, total_bytes-index_bytes-COALESCE(toast_bytes,0) AS table_bytes \
    FROM ( SELECT c.oid,nspname AS table_schema, relname AS TABLE_NAME , c.reltuples AS row_estimate , pg_total_relation_size(c.oid) AS total_bytes , \
    pg_indexes_size(c.oid) AS index_bytes , pg_total_relation_size(reltoastrelid) AS toast_bytes \
    FROM pg_class c \
    LEFT JOIN pg_namespace n ON n.oid = c.relnamespace \
    WHERE relkind = 'r' ) a ) a;"
  else
    local sql="SELECT COALESCE(sum(total_bytes),-1) AS total_bytes FROM ( SELECT *, total_bytes-index_bytes-COALESCE(toast_bytes,0) AS table_bytes \
    FROM ( SELECT c.oid,nspname AS table_schema, relname AS TABLE_NAME , c.reltuples AS row_estimate , pg_total_relation_size(c.oid) AS total_bytes , \
    pg_indexes_size(c.oid) AS index_bytes , pg_total_relation_size(reltoastrelid) AS toast_bytes \
    FROM pg_class c \
    LEFT JOIN pg_namespace n ON n.oid = c.relnamespace \
    WHERE relkind = 'r' ) a ) a \
    WHERE table_schema LIKE '$5' \
    GROUP BY table_schema;"
  fi
  local dbsize=`${pgbin}/psql ${1} -p ${2} -U ${3} --dbname=${4} -A -t -c "${sql}"`
  if [ "${dbsize}" == "" ]; then
    dbsize=-1
  fi
  echo "${dbsize}"
}

# Mark a single run job as started in the database
# $1 jobid
# $2 job class/type [DUMP|RESTORE]
function setsinglerunstarted {
  local sql="SELECT put_singlerun($1, '$2')"
  ${PGSCBIN}/psql ${PGSCHOST} -p ${PGSCPORT} -U ${PGSCUSER} --dbname=${PGSCDB} -c "$sql" > /dev/null
}

# Verify and write upload data for the catalog database
# Checks format based on file name pattern (destination table) and regular expression
# $1 datarow (pgsql copy format)
# $2 destination file
# $3 file: [ADD|NEW]
# $4 optional: UPLOAD (creates link in upload dir)
function preparecatalogdata {
  if [ "$1" == "" ]; then
    return
  fi

  local format=`echo "${2}" | awk -F '.' '{print $(NF-1)}'`
  # Verify the upload format using regular expression
  if [ "${format}" == "catalog" ]; then
    if [ "`echo -e "${1}" | grep -E '^\d+\t\d{8}T\d{6}\t\d{8}T\d{6}\t[A-Z]+\t[a-zA-Z0-9_\.\/]+\t[a-zA-Z0-9_\./]+\t-?\d+\t-?\d+$'`" == "" ]; then
      snaplog "ERROR" "catalog upload wrong format: $1"
      return
    fi
  elif [ "${format}" == "message" ]; then
    if [ "`echo -e "${1}" | grep -E '^\d{8}T\d{6}\t((INFO|WARNING|ERROR|DEBUG))\t.+\t.*\t((CACHE_CONFIG|DUMP|RESTORE))\t-?\d+$'`" == "" ]; then
      snaplog "ERROR" "message upload wrong format: $1"
      return
    fi
  else
      snaplog "ERROR" "catalog upload format unknown: $2"
      return
  fi
  
  # Add to existing file, or overwrite
  if [ "${3}" == "ADD" ]; then
    echo -e "${1}" >> ${2}
  else
    echo -e "${1}" > ${2}
  fi
  # Create link in upload dir
  if [ "${4}" == "UPLOAD" ]; then
    ln -s ${2} ${ROOTDIR}/upload/
  fi
}

# Table functions
# -----------------------------------------------------

# Extract a row from a 'table' by first column
# $1 file name with | separated fields
# $2 search value (first field)
function findrow {
  local row=`grep -E "^${2}\|" "${1}"`
  echo "${row}"
}

# Get field value from a row
# $1 row with | separated fields
function getfieldvalue {
  local val=$(echo "${1}" | cut -d '|' -f ${2})
  echo "${val}"
}

# Scripts/files
# ------------------------------------------------------
# Downloads a script, writes it to the script directory
# $1 script name
function getscript {
  local sql="SELECT get_scriptcode('$1')"
  ${PGSCBIN}/psql ${PGSCHOST} -p ${PGSCPORT} -U ${PGSCUSER} --dbname=${PGSCDB} -A -t -c "${sql}" > ${SCRIPTDIR}/$1
}

# =====================================
# Init actions
# =====================================

# Set hostname
FQDN=`hostname -f`

# Try to find the config file, check and read
if [ ! -e ${CONFIGFILE} ]; then
  CONFIGFILE=${SCRIPTPATH}/pgsnapman.config
fi
if [ -e ${CONFIGFILE} ]; then
  . ${CONFIGFILE}
else
  echo "pgsnapman config file not found: "${CONFIGFILE}
  exit 1
fi

# Test for existing root dir
if [ "`echo "${ROOTDIR}" | grep ' '`" != "" ]; then
  echo "ERROR PgSnapMan root name contains spaces [${ROOTDIR}]"
  exit 1
fi
if [ ! -d "${ROOTDIR}" ]; then
  echo "ERROR PgSnapMan root directory does not exist [${ROOTDIR}]"
  exit 1
fi

# Verify user
if [ "`whoami`" != "${PGSNAPMANUSER}" ]; then
  echo "ERROR pgsnapman must run as user: ${PGSNAPMANUSER}"
  exit 4
fi

# Set toolname
TOOLNAME=`basename $0`

# Set script dir
SCRIPTDIR=${ROOTDIR}/script

# Set upload dir
UPLOADDIR=${ROOTDIR}/upload

# Get a timestamp
INITIMESTAMP=`date '+%Y%m%dT%H%M%S'`

# Set the hostname for the pgsnapman database
PGSCHOST=$(resolvepghost ${PGSCHOST})

# Retrieve the worker id for this worker instance (we do not need the catalog db, so we can continue if not found)
BUWORKERID=$(getworkerid)

# Get worker status, quit if HALTED (any tool will quit when the worker is halted)
if [ "$(getworkerstatus)" == "HALTED" ]; then
  exit 6
fi

# Write tool init log entry
if [ "${LOGINIT}" != "NO" ]; then
  snaplog "INFO" "init - using config: ${CONFIGFILE}"
fi

