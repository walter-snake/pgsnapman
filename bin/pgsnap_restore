#!/bin/bash

# pgsnap_restore: starts postgres restore
#                     must run on a backup node, with passwordless (.pgpass does the job) to all database servers
#
# $1 restore job id
# $2 backup path to use, for TRIGGER type: full backup path; for CRON/SINGLE jobs: use 'FROM_JOB' or specify catalog id
# $3 verbosity [VERBOSE|SILENT]
# $4 startup type [CRON|SINGLE|TRIGGER]
#      

# ======================================
# Initialization
# ======================================
JOBID=$1
DUMP=$2
VERBOSITY=$3
STARTTYPE=$4

# Get the script directory (must do this first)
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
SCRIPTPATH="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

# Check cmd args
if [ "${STARTTYPE}" == "" ]; then
  echo "ERROR pgsnap_restore no startup type provided"
  cleanupexit 1
fi

# Catalog database needed?
PGSCDB_REQUIRED=YES

# Load functions, will also perform initialization operations
. ${SCRIPTPATH}/pgsnap_lib

# TOOL_LOG
TOOL_LOG=${LOGDIR}/pgsnap_restore.log

# ==========================================
# Functions
# ==========================================

# Informational helper functions
# ------------------------------

# Retrieve selected backup status from local cache
# $1 path to backup *.catalog.dat file with catalog info (as uploaded)
function getbackupstatus {
  local status=`cat "$1" | cut -d $'\t' -f4`
  echo "${status}"
}

# Retrieve the restore job info from the catalog
# $1 restore job id
function getrestorejob {
  local data
  local sql="SELECT r.id, pgsnap_catalog_id, r.dest_dbname, r.restoretype, \
       r.restoreschema, r.restoreoptions, existing_db, r.cron, r.status, r.comment, \
       r.jobtype, p.dns_name, p.pgport, p.pgsql_superuser, r.role_handling, r.tblspc_handling \
  FROM pgsnap_restorejob r \
  JOIN pgsql_instance p \
    ON r.dest_pgsql_instance_id = p.id \
  WHERE r.id = ${1};"
  data=`${PGSCBIN}/psql ${PGSCHOST} -p ${PGSCPORT} -U ${PGSCUSER} --no-password --dbname=${PGSCDB} -c "$sql" -A -t`
  echo "${data}"
}

# Get the full dumppath from the backup catalog
# $1 dump catalog id
function getdumppathfromcatalog {
  local data
  local sql="SELECT bu_location || '/' || bu_name FROM pgsnap_catalog WHERE id = $1 AND status = 'SUCCESS';"
  data=`${PGSCBIN}/psql ${PGSCHOST} -p ${PGSCPORT} -U ${PGSCUSER} --no-password --dbname=${PGSCDB} -c "$sql" -A -t`
  echo "${data}"
}

# Set postgres server version variable
function setpgbinpath {
  # Check postgres server version and binary availability 
  PGVERSION=$(getpgversion "${pgsqlhost}" "${pgsqlport}" "${pgsqlsuperuser}" "${MAINTDB}")
  if [ "${PGVERSION}" == "" ]; then
    log "ERROR" "job id ${JOBID} - could not connect to postgres instance: ${pgsqlsuperuser}@${pgsqlhost}:${pgsqlport}/${MAINTDB}"
    ERRORS=1
  else
    eval pgbinvar=PGBIN${PGVERSION}
    PGBIN=${!pgbinvar}
  fi
  # check if psql exists
  if [ ! -e ${PGBIN}/psql ]; then
    log "ERROR" "job id ${JOBID} - job can not run - pg tools not found, check PGBINxx paths in config file ${CONFIGFILE}"
    ERRORS=1
  fi
}

# Db management helper functions
# ------------------------------

# Lockout all users (except the superuser, of course)
# $1 database name
function lockoutusers {
  # disable connections
  log "INFO" "prevent new connections to database ${1}"
  ${PGBIN}/psql ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --no-password --dbname=${MAINTDB} -c "UPDATE pg_catalog.pg_database SET datallowconn=false WHERE datname='${1}'" --output=/dev/null

  # close connections
  # get list of connected users, loop through and terminate backends
  log "INFO" "terminate existing connections on database $1"
  ${PGBIN}/psql ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --no-password --dbname=${MAINTDB} -c "select pg_terminate_backend(pid) from pg_stat_activity where datname='${1}'"
  if [ "$?" != "0" ]; then
    snaplog "ERROR" "could not successfully terminate clients, impossible to complete DROP and RENAME operations on database ${1}"
    cleanupexit 1
  fi
}

# Set acl and allow connections
# $1 database name
function setaclallowconnect {
  log "INFO" "set acl and allow new connections to database ${1}"
  if [ -e "${DUMP}.database_acl.sql" ]; then
    ${PGBIN}/psql ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --no-password --dbname=${MAINTDB} -f ${DUMP}.database_acl.sql --output=/dev/null
  fi
  ${PGBIN}/psql ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --no-password --dbname=${MAINTDB} -c "UPDATE pg_catalog.pg_database SET datallowconn=true WHERE datname='${1}'" --output=/dev/null
}

# Drop database
# $1 database name
function dropdatabase {
  # throw everyone out
  lockoutusers $1

  log "INFO" "dropping database $1"
  # drop, this should succeed, as all connections are dead, and no one can be connected any more (well, a superuser)
  ${PGBIN}/psql ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --no-password --dbname=${MAINTDB} -c "DROP DATABASE IF EXISTS \"${1}\"" 2>&1 /dev/null
  if [ "$?" == "0" ]; then
    log "INFO" "database $1 dropped successfully (or did not exist at all)"
  else
    log "ERROR" "error while dropping database $1"
  fi
}

# Rename database
# $1 source database name
# $2 target database name
function renamedatabase {
  # throw everyone out
  lockoutusers $1

  log "INFO" "rename database $1->$2"
  # rename, this should succeed, as all connections are dead, and no one can be connected any more (well, a superuser)
  ${PGBIN}/psql ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --no-password --dbname=${MAINTDB} -c "ALTER DATABASE \"${1}\" RENAME TO \"${2}\"" 2>&1 /dev/null
  if [ "$?" == "0" ]; then
    log "INFO" "database $1 renamed successfully (or did not exist at all)"
  else
    log "ERROR" "error while renaming database $1->$2"
  fi
}

# Create a role, skips setting password when role already exists
# $1 role name (should be sanitized, without double quotes)
function createrole {
  local line=`${PGBIN}/psql ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --no-password --dbname=${MAINTDB} -A -t -c "SELECT count(*) from pg_catalog.pg_roles WHERE rolname = '${1}'"`
  # not present: create from information in globals dump
  if [ "$line" == "1" ]; then
    if [ "${VERBOSITY}" == "VERBOSE" ]; then echo "skip existing role: ${1}"; fi
  else
    if [ "${VERBOSITY}" == "VERBOSE" ]; then echo "create role:        ${1}"; fi
    # load cluster globals dump into psql, filtered for this role
    cat "${DUMP}.cluster_globals.sql" | grep -E "^((ALTER\ ROLE|CREATE\ ROLE))\ \"?${1}.*" | ${PGBIN}/psql ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --dbname=${MAINTDB} --no-password
  fi
}

# Set the DBSETTINGS datarow, with database global settings
#   datname, owner, encoding, collate, ctype, acl_rights, dattablespace
function setDBSETTINGS {
  DBSETTINGS=`cat "${DUMP}.database_settings.list"`
}

# Create temp database
# $1 target database name
# $2 use tablespace [USE_TBLSPC|NO_TBLSPC]
function createdatabase {
  # create the database
  if [ "$2" == "USE_TBLSPC" ] &&  [ "$(getfieldvalue "${DBSETTINGS}" 7)" != "" ]; then
    local tblspc="--tablespace=$(getfieldvalue "${DBSETTINGS}" 7)"
  fi
  log "INFO" "creating database $1"
  ${PGBIN}/createdb ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --no-password --maintenance-db=${MAINTDB} -E $(getfieldvalue "${DBSETTINGS}" 3) --lc-collate=$(getfieldvalue "${DBSETTINGS}" 4) --lc-ctype=$(getfieldvalue "${DBSETTINGS}" 5) --template=template0 ${tblspc} "$1" 2> /dev/null
  echo $?
}

# Set database owner
# $1 target database name
function setdatabaseowner {
  log "INFO" "setting owner on database $1 to $(getfieldvalue "${DBSETTINGS}" 2)"
  # Set owner (failure does not produce an error)
  echo "ALTER DATABASE \"$1\" OWNER TO \"$(getfieldvalue "${DBSETTINGS}" 2)\";" | ${PGBIN}/psql ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --dbname=${MAINTDB} --no-password > /dev/null
}

# Create the roles, neccessary for this database
function prepareroles {
  log "INFO" "preparing roles for restore job ${JOBID} (original database: ${dbname})"
  # check and create database owner
  createrole $(getfieldvalue "${DBSETTINGS}" 2)
  # check and create other roles
  # a bit more complex: read schema, and find all alter owner, grant and revoke rows
  # use pg_restore to read the schema, and grep relevant records
  ${PGBIN}/pg_restore --schema-only ${restoreoptions} "${DUMP}" | grep -E '^((GRANT|REVOKE|ALTER.*OWNER\ TO))' | awk '{if ($1 == "ALTER") print $6; else print $7;}' | grep -iv 'PUBLIC' | sed 's/;//'| sort > ${TEMPDIR}/$$.${JOBID}.pgsnap_restore.roles
  # read user names, create
  local line
  local linetrim
  local previous
  while read line; do
    if [ "${line}" != "${previous}" ]; then
      linetrim=`echo ${line} | sed 's/"//g'`
      createrole "${linetrim}"
    fi
    previous=${line}
  done < ${TEMPDIR}/$$.${JOBID}.pgsnap_restore.roles
}

# Checks every required tablespace
function checktablespaces {
  log "INFO" "verifying tablespaces for restore job ${JOBID} (original database: ${dbname})"
  ${PGBIN}/pg_restore --schema-only ${restoreoptions} "${DUMP}" | grep -E "^SET\ default_tablespace\ \=\ .*[^'];" | awk '{print $4}' | sed 's/;//'| sort > ${TEMPDIR}/$$.${JOBID}.pgsnap_restore.tablespaces
  # read user names, create
  local line
  local linetrim
  local previous
  while read line; do
    if [ "${line}" != "${previous}" ]; then
      linetrim=`echo ${line} | sed 's/"//g'`
      hastablespace "${linetrim}"
    fi
    previous=${line}
  done < ${TEMPDIR}/$$.${JOBID}.pgsnap_restore.tablespaces
}

# Checks if a tablespace exists
# $1 tablespace name (should be sanitized, without double quotes)
function hastablespace {
  local line=`${PGBIN}/psql ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --no-password --dbname=${MAINTDB} -A -t -c "SELECT count(*) from pg_catalog.pg_tablespace WHERE spcname = '${1}'"`
  # not present: create from information in globals dump
  if [ "$line" == "0" ]; then
    if [ "${VERBOSITY}" == "VERBOSE" ]; then echo "required tablespace does not exist: ${1}"; fi
    log "ERROR" "required tablespace $1 does not exist, quit"
    snaplog "ERROR" "required tablespace $1 does not exist, quit"
    cleanupexit 1
  else
    if [ "${VERBOSITY}" == "VERBOSE" ]; then echo "required tablespace found: ${1}"; fi
  fi
}

# Restore procedures
# --------------------------

# SQL restore
function run_sql_restore {
  snaplog "INFO" "starting cluster dump restore"; 
  gunzip -c ${DUMP} | ${PGBIN}/psql ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --dbname=${MAINTDB} ${restoreoptions}
   if [ "$?" == "0" ]; then
     snaplog "INFO" "finished restoring cluster dump"; 
   else
     snaplog "ERROR" "errors while restoring cluster dump"; 
   fi
}

# DIR dump restore
function run_dir_restore {
  # Load the settings for this dump
  setDBSETTINGS

  # restore type DATA: no database manipulation
  if [ "${restoretype}" == "DATA" ]; then
    RESTOREDB="${dbname}"
  else
    # temp name, we always run restore in a temp database
    RESTOREDB="${dbname}_$$"
  
    # prepare roles
    if [ "${rolehandling}" == "USE_ROLE" ]; then
      prepareroles
    fi

    # tablespaces
    if [ "${tblspchandling}" == "USE_TBLSPC" ]; then
      checktablespaces
    fi

    # create database
    local ec=$(createdatabase ${RESTOREDB} ${tblspchandling})
    # if this fails, we'll bail out
    if [ "$ec" != "0" ]; then
      snaplog "ERROR" "database creation failed for temp database ${RESTOREDB}"
      echo "$ec"
      return
    fi

    # drop before (risky, but possible, could come in handy when space is restricted)
    if [ "${existingdb}" == "DROP_BEFORE" ]; then
      ec="$(dropdatabase "${dbname}")"
    fi
  fi
  # end DATA exlusion

  # restore, depends on DATA/SCHEMA/FULL
  log "INFO" "processing - restore to temp database ${RESTOREDB} started"
  ${PGBIN}/pg_restore ${pgsqlhost} -p ${pgsqlport} -U ${pgsqlsuperuser} --no-password --dbname=${RESTOREDB} ${restoreoptions} "${DUMP}"
  if [ "$?" == "0" ]; then
    log "INFO" "processing - restore to temp database ${RESTOREDB} completed"
  else
    log "ERROR" "processing - restore to temp database ${RESTOREDB} failed, abort restore, trying to drop temp database"
    snaplog "ERROR" "processing - restore to temp database ${RESTOREDB} failed, abort restore, trying to drop temp database"
    ec=$(dropdatabase "${RESTOREDB}")
    echo "1"
    return
  fi
  
  # restore type DATA: no database manipulation
  if [ "${restoretype}" != "DATA" ]; then
   # drop/move original after restore
    if [ "${existingdb}" == "DROP" ]; then
      ec="$(dropdatabase "${dbname}")"
    elif  [ "${existingdb}" == "RENAME" ]; then
      # always drop existing backup in rename scenario
      ec="$(dropdatabase "${dbname}_pgsnapman_rs_bak")"
      ec="$(renamedatabase "${dbname}" "${dbname}_pgsnapman_rs_bak")"
    fi
  
    # move in place
    ec="$(renamedatabase "${RESTOREDB}" "${dbname}")"
  
    # Only when USE_ROLE
    if [ "${rolehandling}" == "USE_ROLE" ]; then
      # set owner
      setdatabaseowner ${dbname}
      # set global acl and allow connections
      setaclallowconnect ${dbname}
    fi
  fi  
  # end DATA exclusion
  snaplog "INFO" "finished restore of database $(getfieldvalue "${DBSETTINGS}" 1) -> ${dbname}"
}

# ==========================================
# MAIN
# ==========================================

# Get restore information from the database, startup specials
# - should check backup catalog for SUCCESS of the specific dump job, but not in case of a TRIGGER start (catalog entry probably not present)
# - SINGLE job must register in the pgsnap_singlerun table as soon as it is started (to prevent a new start)
# We don't want to start a new restore operation while this one is running (same for backups, but there it gives system load/lockup, restore could potentially break integrity).

errcode=0
errmsg=""

# Verify starttype
if [[ ! "${STARTTYPE}" =~ ^((CRON|SINGLE|TRIGGER))$ ]]; then
  snaplog "ERROR" "wrong start type (${STARTTYPE})"
  cleanupexit 1
fi

# Check if not another restore process is already running (can be only one file, as a new one will only be written when there's no lock file present
findresult=`find ${TEMPDIR} -name "*.$1.pgsnap_restore.running"`
if [ "${findresult}" != "" ]; then
  chkpid=`echo "${findresult}" | cut -d '.' -f1`
  chkpid=`basename ${chkpid}`
  ps -p $chkpid &> /dev/null
  if [ "$?" == "1" ]; then
    rm -f ${findresult}
  else
    errmsg="process with pid ${chkpid} is already running for job id ${JOBID}" 
    log "WARNING" "${MSG}"
    errcode=2
  fi
fi

# Get restore job information
restorejob="$(getrestorejob ${JOBID})"
if [ "${restorejob}" == "" ]; then
  errmsg="job id ${JOBID} not found or of wrong type (${STARTTYPE})"
  log "ERROR" "${errmsg}"
  errcode=3
fi

# Get the various restore job fields
catalogid="$(getfieldvalue "${restorejob}" 2)"
dbname="$(getfieldvalue "${restorejob}" 3)"
restoretype="$(getfieldvalue "${restorejob}" 4)"
restoreschema="$(getfieldvalue "${restorejob}" 5)"
restoreoptions="$(getfieldvalue "${restorejob}" 6)"
existingdb="$(getfieldvalue "${restorejob}" 7)"
cron="$(getfieldvalue "${restorejob}" 8)"
status="$(getfieldvalue "${restorejob}" 9)"
comment="$(getfieldvalue "${restorejob}" 10)"
jobtype="$(getfieldvalue "${restorejob}" 11)"
pgsqlhost="$(getfieldvalue "${restorejob}" 12)"
pgsqlport="$(getfieldvalue "${restorejob}" 13)"
pgsqlsuperuser="$(getfieldvalue "${restorejob}" 14)"
rolehandling="$(getfieldvalue "${restorejob}" 15)"
tblspchandling="$(getfieldvalue "${restorejob}" 16)"

# Depending on job type, choose restore options
# TRIGGER: all information available
# SINGLE/CRON: need to get the path
if [ "${STARTTYPE}" != "TRIGGER" ]; then
  if [[ "${DUMP}" =~ ^[0-9]+$ ]]; then
    catalogid=${DUMP}
  fi
  DUMP=$(getdumppathfromcatalog ${catalogid})
fi

# Figure out type (cluster/sql or database/directory dump)
if [[ "${DUMP}" =~ .sql.gz$ ]]; then
  dumptype=SQL
  DUMP=`echo "${DUMP}" | sed -E 's/.sql.gz$//g'`
else
  dumptype=DIR
fi

# Check status of the backup job
if [ ! -e ${DUMP}.catalog.dat ] || [ "$(getbackupstatus ${DUMP}.catalog.dat)" != "SUCCESS" ]; then
  errmsg="backup ${DUMP} does not exist, or failed, restore not started" 
  log "ERROR" "${errmsg}" 
  errcode=4
fi

pgsqlhost=$(resolvepghost ${pgsqlhost})

# Set postgres destination server version (also connection test)
setpgbinpath
if [ "${ERRORS}" != "" ]; then
  snaplog "ERROR" "could not connect to target database"
  cleanupexit 1
fi

# Set the options
if [ "${restoretype}" != "SQL" ]; then
  log "INFO" "schema, tablespace and owner/privilege options are ignored in SQL mode"
  if [ "${restoretype}" == "DATA" ]; then 
    restoreoptions="${restoreoptions} --data-only"
  fi
  if [ "${restoretype}" == "SCHEMA" ]; then 
    restoreoptions="${restoreoptions} --schema-only"
  fi
  if [ "${restoreschema}" != "*" ]; then
    restoreoptions="${restoreoptions} --schema=\"${restoreschema}\""
  fi
  if [ "${rolehandling}" == "NO_ROLE" ]; then
    restoreoptions="${restoreoptions} --no-owner --no-privileges"
  fi
  if [ "${tblspchandling}" == "NO_TBLSPC" ]; then
    restoreoptions="${restoreoptions} --no-tablespaces"
  fi
fi

# Be talkative
if [ "${VERBOSITY}" == "VERBOSE" ]; then
  echo "dump catalog id         ${catalogid}"
  echo "destination host:       ${pgsqlhost} (version: $PGVERSION)"
  echo "destination port:       ${pgsqlport}"
  echo "destination db name:    ${dbname}"
  echo "destination superuser:  ${pgsqlsuperuser}"
  echo "restore type:           ${restoretype}"
  echo "restore schema:         ${restoreschema}"
  echo "full restore options:   ${restoreoptions}"
  echo "existing db:            ${existingdb}"
  echo "cron:                   ${cron}"
  echo "status:                 ${status}"
  echo "comment:                ${comment}"
  echo "job type:               ${jobtype}"
  echo "role handling:          ${rolehandling}"
  echo "tablespace handling:    ${tblspchandling}"
  echo ""
  echo "full dump path:         ${DUMP}"
  echo "dump type:              ${dumptype}"
  echo ""
  if [ "${errmsg}" != "" ]; then
    echo "ERROR: ${errmsg}"
  fi
fi

# Ready to go or not?
if [ ${errcode} -gt 0 ]; then
  snaplog "ERROR" "initialization errors, exit code: ${errcode} (${errmsg})"
  cleanupexit ${errcode}
fi

# Write the start markers (lock file, single run in database)
# Single job: write marker to database
echo "${DUMP}" > ${TEMPDIR}/$$.${JOBID}.pgsnap_restore.running
if [ "${STARTTYPE}" == "SINGLE" ]; then
  setsinglerunstarted ${JOBID} 'RESTORE'
fi

# Log message
log "INFO" "starting ${STARTTYPE} restore, job id [${JOBID}] from dump [`basename ${DUMP}`]"
snaplog "INFO" "init - starting ${STARTTYPE} restore, job id [${JOBID}] from dump [`basename ${DUMP}`]"

# Start psql or pg_restore operation
if [ "${dumptype}" == "DIR" ]; then
  run_dir_restore
elif  [ "${dumptype}" == "SQL" ]; then
  run_sql_restore
fi

# Normal end
cleanupexit 0

